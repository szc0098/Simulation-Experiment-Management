/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.myDsl.ModelSection
import org.xtext.example.mydsl.myDsl.Experiment

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MyDslGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		fsa.generateFile('ishc.properties', toISHCProperties(resource.allContents
				.filter(typeof(ModelSection)).head))
		fsa.generateFile('delivery.properties', toDeliveryProperties(resource.allContents
				.filter(typeof(ModelSection)).head , resource.allContents.filter(typeof(Experiment)).head))
		fsa.generateFile("KupfferCell.java", toKupfferCell(resource.allContents
				.filter(typeof(ModelSection)).head))
		fsa.generateFile("Hepatocyte.java", toHepatocyte(resource.allContents
				.filter(typeof(ModelSection)).head))
	}
	
	def toISHCProperties(ModelSection m) '''
		# model parameters
		stepsPerCycle = 1
		# component parameters
		«FOR factor : m.parameters » 
			«IF(factor != null)»
				«IF(factor.factorValue != null)»
					«IF(factor.factorValue.function != null)»
					«factor.factorName» = «factor.factorValue.function»
					«ELSEIF(factor.factorValue.FVal != null)»
					«factor.factorName» = «factor.factorValue.FVal»
					«ELSEIF(factor.factorValue.fvalue != null)»
					«factor.factorName» = «factor.factorValue.fvalue»
					«ELSEIF(factor.factorValue.value != null)»
					«factor.factorName» = «factor.factorValue.value»
		    	«ENDIF»
		 «ENDIF»
		 «ENDIF»
		«ENDFOR»
		
	'''
	
	def toDeliveryProperties(ModelSection m, Experiment e)
	'''
	deliveryType = bolus
	useContinualDoseFunction = false
	repeatDose = true
	infusionStopTime = 120.0
	numDoses = 1
	time.0 = 1.0
	time.1 = 10.0
	dose.0.alpha = 2000
	dose.0.beta = -1
	dose.0.gamma = -2
	dose.0.numEntries = 7
	«var count1 = -1»
	 
	«FOR factor : m.parameters » 
			«IF(factor != null )»
				#«count1++»
				«IF(factor.factorProperties != null)»
					«var count2 = 0»
					«FOR p : factor.factorProperties»
					
						
						«IF(!(p.PName.equals("membraneCrossing") || p.PName.equals("bileRatio") ||
						p.PName.equals("core2Rim") || p.PName.equals("metProbStart") ||
						p.PName.equals("metProbFinish") || p.PName.equals("metabolites") ||
						p.PName.equals("inflammatory") || p.PName.equals("pDegrade") || p.PName.equals("transportOut")))»
						
						«IF(p.PVal.FVal != null)»
						dose.0.solute.«count1».«p.PName» = «p.PVal.FVal»
						«ELSEIF(p.PVal.function != null)»
						dose.0.solute.«count1».«p.PName» = «p.PVal.function»
						«ELSEIF(p.PVal.value != null)»
						dose.0.solute.«count1».«p.PName» = «p.PVal.value»
						«ELSEIF(p.PVal.fvalue != null)»
						dose.0.solute.«count1».«p.PName» = «p.PVal.fvalue»
						«ENDIF»
					«ELSEIF(p.PName.equals("bileRatio") || p.PName.equals("core2Rim") || 
						p.PName.equals("metProbStart") || p.PName.equals("metProbFinish") ||
						p.PName.equals("inflammatory") || p.PName.equals("pDegrade"))»
						dose.0.solute.«count1».property.«count2».key = «p.PName»
						dose.0.solute.«count1».property.«count2».type = real
						
						
						«IF(p.PVal.FVal != null)»
						dose.0.solute.«count1».property.«count2++».val =  «p.PVal.FVal»
						«ELSEIF(p.PVal.function != null)»
						dose.0.solute.«count1».property.«count2++».val =  «p.PVal.function»
						«ELSEIF(p.PVal.value != null)»
						dose.0.solute.«count1».property.«count2++».val =  «p.PVal.value»
						«ELSEIF(p.PVal.fvalue != null)»
						dose.0.solute.«count1».property.«count2++».val =  «p.PVal.fvalue»
						«ENDIF»
						
					«ELSEIF(p.PName.equals("membraneCrossing") || p.PName.equals("transportOut"))»
						dose.0.solute.«count1».property.«count2».key = «p.PName»
						dose.0.solute.«count1».property.«count2».type = boolean
						
						
						«IF(p.PVal.FVal != null)»
						dose.0.solute.«count1».property.«count2++».val =  «p.PVal.FVal»
						«ELSEIF(p.PVal.function != null)»
						dose.0.solute.«count1».property.«count2++».val =  «p.PVal.function»
						«ELSEIF(p.PVal.value != null)»
						dose.0.solute.«count1».property.«count2++».val =  «p.PVal.value»
						«ELSEIF(p.PVal.fvalue != null)»
						dose.0.solute.«count1».property.«count2++».val =  «p.PVal.fvalue»
						«ENDIF»
					«ELSEIF(p.PName.equals("metabolites"))»

							«IF(e.expDesign.variables.independentVariables.variables != null)»
							«FOR factorLevels : e.expDesign.variables.independentVariables.variables»
							«IF(factorLevels.facName.equals((p.PVal.function.split('-').get(0))))»
							«IF(factorLevels.l != null)»
								dose.0.solute.«count1».property.«count2».key = metabolites
								dose.0.solute.«count1».property.«count2».type = map
								dose.0.solute.«count1».property.«count2++».val =  «p.PVal.function.split('-').get(1)» => <«factorLevels.l»>
							«ELSEIF(factorLevels.start1 != null && factorLevels.end1 != null)»
								dose.0.solute.«count1».property.«count2».key = metabolites
								dose.0.solute.«count1».property.«count2».type = map
								dose.0.solute.«count1».property.«count2++».val =  «p.PVal.function.split('-').get(1)» => <«factorLevels.start1»,«factorLevels.end1»>
							«ENDIF»
							«ENDIF»
							«ENDFOR»
							«ENDIF»
						
						«ENDIF»
					«ENDFOR»
		    	«ENDIF»
		 «ENDIF»
		«ENDFOR»
     '''
     
     def toKupfferCell(ModelSection m)'''
	
		
		package ishc.model;
		import java.lang.Math;
		import sim.field.grid.*;
		import sim.util.Bag;
		
		public class KupfferCell extends Cell {
		    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger( ISHC.class );
		    
		    public KupfferCell(Culture p, ec.util.MersenneTwisterFast random, int x, int y) {
		        super(p,random);
		        setLoc(x,y);
		        
		        actionShuffler.clear();         
		        actionShuffler.add(new Runnable() { public void run() { handleInflammation(); } });
		        actionShuffler.add(new Runnable() { public void run() { handleDegradation();}} );
		    }
		    
		    BolusEntry cytokineBolusEntry = null;
		    public void handleInflammation()
		    {
		        int numInflammatoryStimuli = 0;
		        int numCytokines = 0;
		        for(Object o : solutes)
		        {
		            Solute s = (Solute) o;
		            if(s.hasProperty("inflammatory") && ((Boolean)s.getProperty("inflammatory")))
		            {
		                numInflammatoryStimuli++;
		            }
		            if(s.type.equals("Cytokine"))
		            {
		                numCytokines++;
		            } 
		            «FOR mech : m.mechanisms»
	
					«IF(mech.LHS.agent != null && mech.LHS.agent1 != null)»
	
					«IF(mech.LHS.agent.equalsIgnoreCase("Kupffercells") || mech.LHS.agent.equalsIgnoreCase("Kupffercell"))»
		           		 if(s.type.equals("«mech.LHS.agent1»"){
		            	
		            	«IF(mech.condition != null)»
		            	if("«mech.condition.condition1»" «mech.condition.link» "«mech.condition.condition2»")
		            	«ENDIF»
		            	«IF(mech.RHS.agent1 != null)»
		            		«IF(mech.RHS.agent1.equalsIgnoreCase("Cytokines") || mech.RHS.agent1.equalsIgnoreCase("Cytokine"))»
		            			numCytokines++;	  
		            		«ELSEIF(mech.RHS.agent1.equalsIgnoreCase("Inflammation") || mech.RHS.agent1.equalsIgnoreCase("InflammatoryAgent"))»
		            			numInflammatoryStimuli++;
		            	     «ELSEIF(mech.RHS.agent1.equalsIgnoreCase("No Inflammation")|| mech.RHS.agent1.equalsIgnoreCase("NoInflammation"))»
		            			numInflammatoryStimuli--;
		            		«ENDIF»
		            	     «ENDIF»
		            	 «IF(mech.RHS.agent != null)»
		            	     «IF(mech.RHS.agent.equals("Cytokines") || mech.RHS.agent.equals("Cytokine"))»
		            	     	numCytokines++;	  
		            	     «ELSEIF(mech.RHS.agent.equalsIgnoreCase("Inflammation") || mech.RHS.agent.equalsIgnoreCase("InflammatoryAgent"))»
		            			numInflammatoryStimuli++;
		            	     «ELSEIF(mech.RHS.agent.equalsIgnoreCase("No Inflammation")|| mech.RHS.agent.equalsIgnoreCase("NoInflammation"))»
		            			numInflammatoryStimuli--;
		            		«ENDIF»
		            	  «ENDIF»
		            	  	
		

	«ENDIF»
	«ENDIF»
	«ENDFOR»
		            	     
		            	  }
		            }
		        }
		
		
		        if(numCytokines >= parent.cytokineThreshold)
		        {
		            return;
		        }
		        
		
		        if(numInflammatoryStimuli >= parent.inflammatoryStimulusThreshold)
		        {               
		            double probability = 1.0 - Math.exp(-1*(numInflammatoryStimuli - parent.inflammatoryStimulusThreshold) / parent.exponentialFactor);
		            
		            double draw = rng.nextDouble();
		            if(draw <= probability)
		                addCytokine();
		        }
		    }
		    
		    public Solute addCytokine()
		    {
		
		        if(cytokineBolusEntry == null)
		        {
		            sim.util.Bag bolusEntries = ((BolusDose) parent.model.delivery.doses.objs[0]).solution;
		            for (int i = 0; i < bolusEntries.numObjs; i++) {
		                BolusEntry be = (BolusEntry) bolusEntries.objs[i];
		                if (be.tag.equals("Cytokine")) {
		                    cytokineBolusEntry = be;
		                    break;
		                }
		            }
		        }
		        
		        //Create the Cytokine
		        Solute cytokine = new Solute(cytokineBolusEntry);
		        cytokine.setProperties(cytokineBolusEntry.props);
		
		        //Add the Cytokine
		        parent.solutes.add(cytokine);
		        parent.cellSpace.setObjectLocation(cytokine, myX, myY);
		        solutes.add(cytokine);
		        
		        return cytokine;
		    }
		}
	
	
	'''
	
	def toHepatocyte(ModelSection m) '''
	
		package ishc.model;
		
		import java.util.HashMap;
		import java.util.LinkedHashMap;
		import sim.util.Bag;
		import sim.util.Double2D;
		
		public class Hepatocyte extends Cell implements CellInfo, EIInfo, ELInfo, MetabolismInfo {
		    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger( ISHC.class );
		    HashMap<String, Double> metProbMap = new LinkedHashMap<String,Double>();
		    HashMap<String, HashMap<String,Double>> productionMap = new LinkedHashMap<String,HashMap<String,Double>>();
		    
		    int numEnzymesAtInit = -Integer.MAX_VALUE;
		    public Hepatocyte(Culture p, ec.util.MersenneTwisterFast random, int x, int y) {
		      super(p, random);
		      setLoc(x,y);
		
		        if (parent.ei_rate > 0.0) {
		            actionShuffler.add(new EIHandler((CellInfo) this, (BindingInfo) this, (EIInfo) this, log));
		        }
		        if (parent.el_rate > 0.0) {
		            actionShuffler.add(new ELHandler((CellInfo) this, (BindingInfo) this, (ELInfo) this, log));
		        }
		        if (parent.useDDI) {
		            actionShuffler.add(new DDIHandler((BindingInfo) this, rng, log, parent.pReplace));
		        }       
		        if (parent.drRate > 0) {
		            actionShuffler.add(new Runnable() { public void run() { handleDownRegulation(); } });
		        }
		    }
		
		    float ENZYME_INIT_FACTOR = 3.0f;
		    public void init() {    
		      int min = StrictMath.round(parent.bindmin);
		      int max = StrictMath.round(parent.bindmax);
		      try {
		        numEnzymesAtInit = rng.nextInt(max-min) + min;
		      } catch (IllegalArgumentException e) {
		          numEnzymesAtInit = min;
		      }    
		
		      for (int bNdx=0 ; bNdx<numEnzymesAtInit; bNdx++) 
		        binders.add(new Enzyme());
		
		      for (Object o : ((BolusDose)parent.model.delivery.doses.objs[0]).solution) {
		        BolusEntry be = (BolusEntry) o;
		        if (be.bindable) {
		          double mps = (Double)be.props.get("metProbStart");
		          double mpf = (Double)be.props.get("metProbFinish");          
		          double mp = mps + (mpf-mps)*0.5;
		          metProbMap.put(be.tag, mp);
		
		          HashMap<String,Double2D> mprodmap = (HashMap<String,Double2D>) be.props.get("metabolites");
		          HashMap<String,Double> metsMap = new LinkedHashMap<>();
		          for (java.util.Map.Entry<String,Double2D> me : mprodmap.entrySet()) {
		            Double2D d2d = me.getValue();
		            double prmin = d2d.x;
		            double prmax = d2d.y;
		            double prodRate = prmin + (prmax-prmin)*0.5;
		            metsMap.put(me.getKey(), prodRate);
		          }
		          productionMap.put(be.tag,metsMap);
		        }
		      }
		      
		        if (!metProbMap.isEmpty()) {
		            actionShuffler.add(new MetabolismHandler((BindingInfo) this, (MetabolismInfo) this, rng, log));
		        }
		    }
		    
		    public java.util.ArrayList<ishc.util.MyInt> elimQueue = null;
		    int rate_increment = parent.drRate;
		    public void handleDownRegulation()
		    {      
		
		        boolean thereIsACytokine = false;
		        «FOR mech : m.mechanisms»
				«IF(mech.LHS.agent != null && mech.LHS.agent1 != null)»
				«IF(mech.LHS.agent1.equalsIgnoreCase("Hepatocyte") || mech.LHS.agent.equalsIgnoreCase("Hepatocyte"))»	
		        «IF(mech.RHS.agent1 != null) &&
		         (mech.RHS.agent1.equalsIgnoreCase("Cytokines") || mech.RHS.agent1.equalsIgnoreCase("Cytokine"))»
		            	«IF(mech.condition != null)»
						if("«mech.condition.condition1»" «mech.condition.link» "«mech.condition.condition2»"){
							thereIsACytokine = true;
							}
		            	«ENDIF»		       		        
		        «ELSE»
		        for(Solute s : solutes)
		        {
		            if(s.type.equalsIgnoreCase("Cytokine"))
		            {
		                thereIsACytokine = true;
		                break;
		            }
		        }
		        «ENDIF»
		         « IF(mech.RHS.agent1 != null) &&
		         (mech.RHS.agent1.equalsIgnoreCase("Enzymes") || mech.RHS.agent1.equalsIgnoreCase("Enzyme"))»
		            	«IF(mech.condition != null)»
						if("«mech.condition.condition1»" «mech.condition.link» "«mech.condition.condition2»"){
		         			binders.add(new Enzyme());
		            		return;
		            	}
		            	«ENDIF»
		         «ELSE»
		         if(binders.size() < numEnzymesAtInit && elimQueue != null && elimQueue.size() == 0 && !thereIsACytokine)
		        {            
		            if(rng.nextDouble() < parent.drReplenish)
		                binders.add(new Enzyme());
		            return;
		        }
		        «ENDIF»
		        if(elimQueue != null && elimQueue.size() > 0)
		        {
		            int num_to_elim = (int) elimQueue.remove(0).val;
		            java.util.ArrayList<Binder> to_be_removed = new java.util.ArrayList<Binder>();
		            for(Binder b : binders)
		            {
		                if(num_to_elim <= 0)
		                    break;
		                if(!bound.containsKey(b)) //if unbound
		                    to_be_removed.add(b);
		                if(to_be_removed.size() >= num_to_elim)
		                    break;
		                «IF(mech.RHS.agent1.contains("Removed"))»
		                if(!bound.containsKey("«mech.RHS.agent1.substring(mech.RHS.agent1.indexOf("Removed"))»")) //if unbound
		                    to_be_removed.add(b);
		                    «ENDIF»
		                «IF(mech.RHS.agent1.contains("Added"))»
		                if(!bound.containsKey("«mech.RHS.agent1.substring(mech.RHS.agent1.indexOf("Added"))»)") //if unbound
		                    to_be_removed.remove(b);
		                    «ENDIF»
		                    «ENDIF»
	«ENDIF»
	«ENDFOR»
		            }
		 
		            for(Binder b : to_be_removed)
		                binders.remove(b);
		        }
		        
		        Binder firstUnbound = null;
		        for(Binder b : binders)
		        {
		            if(!bound.containsKey(b))
		            {
		                firstUnbound = b;
		                break;
		            }
		        }
		        if(firstUnbound == null)
		            return;                
		
		        for(Solute s : solutes)
		        {
		            if(s.type.equalsIgnoreCase("Cytokine"))
		            {
		                if(rng.nextDouble() < parent.drRemove)
		                {
		                    //Add to the queue to be removed, then return
		                    if(elimQueue == null)
		                        elimQueue = new java.util.ArrayList<ishc.util.MyInt>();
		                                        
		                    for(int i = 0; i < rate_increment - 1; i++)
		                    {
		                        elimQueue.add(new ishc.util.MyInt(0));
		                    }
		                    elimQueue.add(new ishc.util.MyInt(1));
		                    return;
		                }
		            }
		        }
		    }
		    
		    //Implementations for CellInfo
		    public double getResources() {
		        return parent.resources;
		    }
		    public int getBindmax() {return parent.bindmax;}
		    public int getNumEnzymesAtInit() {return numEnzymesAtInit; }
		        
		    //Implementations for EIInfo
		    public int getEIThresh() {return parent.ei_thresh;}
		    public double getEIRate() {return parent.ei_rate;}
		    public double getEIResponse() {return parent.ei_response_factor;}
		    
		    //Implementations for ELInfo
		    public int getELThresh() {return parent.el_thresh;}
		    public double getELRate() {return parent.el_rate;}
		    public double getELResponse() {return parent.el_response_factor;}
		    
		    //Implementations for MetabolismInfo
		    public HashMap<String, Double> getMetProbMap() {return metProbMap;}
		    public HashMap<String, HashMap<String,Double>> getProductionMap() {return productionMap; }
		    public Bag getBolusEntries() {return ((BolusDose) parent.model.delivery.doses.objs[0]).solution; }
		    public void removeSolute(Solute s) {
		        solutes.remove(s);
		        parent.solutes.remove(s);
		        parent.cellSpace.remove(s);
		    }
		    public void addSolute(Solute s) {
		        parent.solutes.add(s);
		        parent.cellSpace.setObjectLocation(s, myX, myY);
		        solutes.add(s);
		    }
		}

	
	'''
}
